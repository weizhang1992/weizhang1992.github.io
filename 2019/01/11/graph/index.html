<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>graph | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
<meta property="og:type" content="article">
<meta property="og:title" content="graph">
<meta property="og:url" content="http://yoursite.com/2019/01/11/graph/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-02-08T03:30:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="graph">
<meta name="twitter:description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-graph" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/11/graph/" class="article-date">
  <time datetime="2019-01-11T18:54:18.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      graph
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>basic knowledge</li>
<li>representation</li>
<li>basic traverse, found path, print path, maze</li>
<li>cycle detection</li>
<li>connectivity</li>
<li>shortest path</li>
<li>schedule networks/dependency</li>
<li>advanced: spanning tree, euler cycle, hamliton cycle, maxflow</li>
<li>questions</li>
</ol>
<h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><ol>
<li>connected graph</li>
<li>strongly connected</li>
<li>weekly connected</li>
<li>tree</li>
<li>spanning tree</li>
<li>min spanning tree</li>
<li>cycle</li>
<li>acyclic</li>
</ol>
<h2 id="representation"><a href="#representation" class="headerlink" title="representation"></a>representation</h2><ol>
<li>objects and pointers:</li>
<li>matrix: graph[][], graph[i][j] = 1 means i and j are connected </li>
<li>adjacent list: List&lt;List<integer>&gt; graph</integer></li>
</ol>
<h2 id="basic-traverse-found-path-print-path-maze"><a href="#basic-traverse-found-path-print-path-maze" class="headerlink" title="basic traverse, found path, print path, maze"></a>basic traverse, found path, print path, maze</h2><ol>
<li>dfs: </li>
</ol>
<ul>
<li>recursion: same memory cost as iterative way, stack memory .vs. heap memory</li>
<li>iterative: stack</li>
<li>time complexity: O(V + E)</li>
<li>use case: Generate Maze, check if exist a path, print path, cycle detection</li>
<li><p><a href="https://leetcode.com/problems/robot-room-cleaner/" target="_blank" rel="noopener">robot-room-cleaner</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Design an algorithm to clean the entire room using only the 4 given APIs shown below.</span></span><br><span class="line"><span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot robot)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    dfs(visited, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, robot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Set&lt;String&gt; visited, <span class="keyword">int</span> curDir, <span class="keyword">int</span> x, <span class="keyword">int</span> y, Robot robot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//we will make sure current point is unvisited and can be cleaned</span></span><br><span class="line">    String key = x + <span class="string">","</span> + y;</span><br><span class="line">    visited.add(key);</span><br><span class="line">    robot.clean();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextDir = (curDir + i) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = dirs[nextDir];</span><br><span class="line">        <span class="keyword">int</span> nextX = x + next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextY = y + next[<span class="number">1</span>];</span><br><span class="line">        String nextKey = nextX + <span class="string">","</span> + nextY;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(nextKey) &amp;&amp; robot.move()) &#123;</span><br><span class="line">            dfs(visited, nextDir, nextX, nextY, robot);</span><br><span class="line">            robot.turnLeft();</span><br><span class="line">            robot.turnLeft();</span><br><span class="line">            robot.move();</span><br><span class="line">            robot.turnLeft();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            robot.turnRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">Longest Increasing Path In Matrix</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs + memorization, time complexity: O(n*m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> [][] offsets = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, findMaxLen(matrix, <span class="number">1</span>, i, j, cache));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxLen</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> tempLen, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] offset : offsets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isInMatrix(matrix, i + offset[<span class="number">0</span>], j + offset[<span class="number">1</span>]) &amp;&amp; matrix[i + offset[<span class="number">0</span>]][j + offset[<span class="number">1</span>]] &gt; matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">1</span> + findMaxLen(matrix, tempLen + <span class="number">1</span>, i + offset[<span class="number">0</span>], j + offset[<span class="number">1</span>], cache);</span><br><span class="line">                curLen = Math.max(curLen, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[i][j] = curLen;</span><br><span class="line">        <span class="keyword">return</span> curLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; matrix.length &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length &amp;&amp; j &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://app.laicode.io/app/problem/218" target="_blank" rel="noopener">Generate Random Maze</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/lyzinskey/laicode/blob/master/Generate%20Random%20Maze/code.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[][] maze(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] maze = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">          maze[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          maze[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generate(maze, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maze;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Dir[] dirs = Dir.values();</span><br><span class="line">    shuffle(dirs);</span><br><span class="line">    <span class="keyword">for</span> (Dir dir : dirs) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextX = dir.moveX(x, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">int</span> nextY = dir.moveY(y, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (isValidWall(maze, nextX, nextY)) &#123;</span><br><span class="line">        maze[dir.moveX(x, <span class="number">1</span>)][dir.moveY(y, <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">        maze[nextX][nextY] = <span class="number">0</span>;</span><br><span class="line">        generate(maze, nextX, nextY);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(Dir[] dirs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * (dirs.length - i));</span><br><span class="line">      Dir tmp = dirs[i];</span><br><span class="line">      dirs[i] = dirs[i + index];</span><br><span class="line">      dirs[i + index] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidWall</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; maze.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; maze[<span class="number">0</span>].length &amp;&amp; maze[x][y] == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">enum</span> Dir &#123;</span><br><span class="line">    NORTH(-<span class="number">1</span>, <span class="number">0</span>), SOUTH(<span class="number">1</span>, <span class="number">0</span>), EAST(<span class="number">0</span>, -<span class="number">1</span>), WEST(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> deltaX;</span><br><span class="line">    <span class="keyword">int</span> deltaY;</span><br><span class="line">    </span><br><span class="line">    Dir(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deltaX = deltaX;</span><br><span class="line">      <span class="keyword">this</span>.deltaY = deltaY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moveX</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + times * deltaX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moveY</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> y + times * deltaY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>围棋判断是否被包围 思<br>路是DFS,一定要问清楚各种条件以及各种算包围的方式。<br>从一个符合条件的点开始做DFS/BFS,遇到边界返回false,<br>在不允许留白的情况下,可以直接遇到白色或者边界 返回false,即没有被包围。</p>
</li>
<li><p><a href="https://leetcode.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">bricks-falling-when-hit</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] hitBricks(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] hits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[hits.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hits.length; i++)</span><br><span class="line">            grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(i) &amp;&amp; grid[<span class="number">0</span>][i] == <span class="number">1</span>)</span><br><span class="line">                search(grid, visited, <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastSize = visited.size();</span><br><span class="line">            <span class="keyword">int</span> x = hits[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = hits[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] != -<span class="number">1</span>) &#123;</span><br><span class="line">                grid[x][y]++;</span><br><span class="line">                <span class="keyword">if</span> (x + <span class="number">1</span> &lt; n &amp;&amp; visited.contains((x + <span class="number">1</span>) * m + y) ||</span><br><span class="line">                    x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; visited.contains((x - <span class="number">1</span>) * m + y) ||</span><br><span class="line">                    y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; visited.contains(x * m + y - <span class="number">1</span>) ||</span><br><span class="line">                    y + <span class="number">1</span> &lt; m &amp;&amp; visited.contains(x * m + y + <span class="number">1</span>) ||</span><br><span class="line">                    x == <span class="number">0</span>) &#123;</span><br><span class="line">                    search(grid, visited, x, y);</span><br><span class="line">                    res[i] = visited.size() - lastSize - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] grid, Set&lt;Integer&gt; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= n || x &lt; <span class="number">0</span> || y &gt;= m || y &lt; <span class="number">0</span> || visited.contains(x * m + y) || grid[x][y] != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(x * m + y);</span><br><span class="line">        search(grid, visited, x - <span class="number">1</span>, y);</span><br><span class="line">        search(grid, visited, x + <span class="number">1</span>, y);</span><br><span class="line">        search(grid, visited, x, y - <span class="number">1</span>);</span><br><span class="line">        search(grid, visited, x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><p>bfs:</p>
<ul>
<li>recursion: no</li>
<li>iterative: Queue or rolling array, node by node, or level by level</li>
<li>time complexity: O(V + E)</li>
<li>use case: Min distance(only deal with weight = 1), </li>
<li><strong>multi-end bfs</strong> to solve </li>
<li><p><a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">Walls and Gates</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//multi-end bfs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] d = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (rooms.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = rooms.length, n = rooms[<span class="number">0</span>].length;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) queue.offer(i * n + j); <span class="comment">// Put gates in the queue</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> i = x / n, j = x % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = i + d[k], q = j + d[k + <span class="number">1</span>]; <span class="comment">// empty room</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= p &amp;&amp; p &lt; m &amp;&amp; <span class="number">0</span> &lt;= q &amp;&amp; q &lt; n &amp;&amp; rooms[p][q] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                rooms[p][q] = rooms[i][j] + <span class="number">1</span>;</span><br><span class="line">                queue.offer(p * n + q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/bus-routes/" target="_blank" rel="noopener">bus-routes</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// what's the minimum stop you need </span></span><br><span class="line"><span class="comment">//what's the minimum bus route you need</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; stopToBus = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; routes[i].length; j ++) &#123;</span><br><span class="line">            stopToBus.putIfAbsent(routes[i][j], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            stopToBus.get(routes[i][j]).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;S, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] head = q.poll();</span><br><span class="line">        <span class="keyword">int</span> curStop = head[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> numOfBus = head[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (curStop == T) &#123;</span><br><span class="line">            <span class="keyword">return</span> numOfBus;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer bus : stopToBus.get(curStop)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(bus)) &#123;</span><br><span class="line">                    visited.add(bus);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routes[bus].length; i++) &#123;</span><br><span class="line">                        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;routes[bus][i], numOfBus + <span class="number">1</span>&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bfs + hashMap, remember check if the node was visited.</span></span><br><span class="line"><span class="comment">//need hashMap for later lookup</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UndirectedGraphNode root = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; nodesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nodesMap.put(node, root);</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode curNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode neighbor : curNode.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodesMap.containsKey(neighbor)) &#123;</span><br><span class="line">                    nodesMap.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                nodesMap.get(curNode).neighbors.add(nodesMap.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">word-ladder-ii</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!wordSet.contains(endWord)) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;List&lt;String&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; candidate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    candidate.add(beginWord);</span><br><span class="line">    q.offer(candidate);</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        List&lt;String&gt; curCandidate = q.poll();</span><br><span class="line">        String cur = curCandidate.get(curCandidate.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span>[] curChars = cur.toCharArray();</span><br><span class="line">        visited.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> old = curChars[i];</span><br><span class="line">                curChars[i] = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line">                String s = String.valueOf(curChars);</span><br><span class="line">                curChars[i] = old;</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(s) &amp;&amp; !visited.contains(s)) &#123;</span><br><span class="line">                    List&lt;String&gt; newCandidate = <span class="keyword">new</span> ArrayList&lt;&gt;(curCandidate);</span><br><span class="line">                    newCandidate.add(s);</span><br><span class="line">                    <span class="keyword">if</span> (s.equals(endWord) &amp;&amp; newCandidate.size() &lt;= minLen) &#123;</span><br><span class="line">                        minLen = newCandidate.size();</span><br><span class="line">                        res.add(newCandidate);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCandidate.size() &lt; minLen) &#123;</span><br><span class="line">                        q.offer(newCandidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*<a href="https://leetcode.com/problems/sliding-puzzle/" target="_blank" rel="noopener">sliding-puzzle</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    String target = <span class="string">"123450"</span>, start = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)</span><br><span class="line">            start += board[i][j];</span><br><span class="line">    HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">1</span>, <span class="number">3</span> &#125;, &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span> &#125;,&#123; <span class="number">1</span>, <span class="number">5</span> &#125;, &#123; <span class="number">0</span>, <span class="number">4</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;, &#123; <span class="number">2</span>, <span class="number">4</span> &#125; &#125;;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// level count, has to use size control here, otherwise not needed</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(target)) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">int</span> zero = cur.indexOf(<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dir : dirs[zero]) &#123;</span><br><span class="line">                String next = swap(cur, zero, dir);</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                    visited.add(next);</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(String str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">    sb.setCharAt(i, str.charAt(j));</span><br><span class="line">    sb.setCharAt(j, str.charAt(i));</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*<a href="https://leetcode.com/problems/shortest-path-to-get-all-keys/" target="_blank" rel="noopener">shortest-path-to-get-all-keys</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys, i, j;</span><br><span class="line">    State(<span class="keyword">int</span> keys, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">this</span>.keys = keys;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathAllKeys</span><span class="params">(String[] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = -<span class="number">1</span>, y = -<span class="number">1</span>, m = grid.length, n = grid[<span class="number">0</span>].length(), max = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'@'</span>) &#123;</span><br><span class="line">                x = i; </span><br><span class="line">                y = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) max = Math.max(c - <span class="string">'a'</span> + <span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    State start = <span class="keyword">new</span> State(<span class="number">0</span>, x, y);</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(<span class="number">0</span> + <span class="string">" "</span> + x + <span class="string">" "</span> + y);</span><br><span class="line">    q.offer(start);</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            State cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.keys == (<span class="number">1</span> &lt;&lt; max) - <span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cur.i + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> j = cur.j + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> keys = cur.keys;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = grid[i].charAt(j);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span> &amp;&amp; ((keys &gt;&gt; (c - <span class="string">'A'</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) keys |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j)) &#123;</span><br><span class="line">                        visited.add(keys + <span class="string">" "</span> + i + <span class="string">" "</span> + j);</span><br><span class="line">                        q.offer(<span class="keyword">new</span> State(keys, i, j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="cycle-detection"><a href="#cycle-detection" class="headerlink" title="cycle detection"></a>cycle detection</h2><ul>
<li><p>undirected graph: dfs with <strong>visited[] and parent</strong> check</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleDetectionInUndirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(i, visit, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">boolean</span>[] visit, List&lt;List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        visit[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node : graph.get(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(node, visit, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>directed graph:<br>  cycle-detection: <a href="http://www.geeksforgeeks.org/detect-cycle-in-a-graph/" target="_blank" rel="noopener">DFS, white, grey, black</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleDetectionInDirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//o represent white, 1 represent grey, 2 represent black</span></span><br><span class="line">        <span class="keyword">int</span>[] nodeColors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeColors[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(i, nodeColors, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] nodeColors, List&lt;List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        nodeColors[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node : graph.get(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeColors[node] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeColors[node] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(node, nodeColors, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeColors[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">LC261:Graph Valid Tree</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle(-<span class="number">1</span>, <span class="number">0</span>, visited, graph)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;  <span class="comment">// has cycle</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: visited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// not 1 single connected component</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">int</span> pred, <span class="keyword">int</span> vertex, <span class="keyword">int</span>[] visited, List&lt;List&lt;Integer&gt;&gt; adjList)</span> </span>&#123;</span><br><span class="line">    visited[vertex] = <span class="number">1</span>;  <span class="comment">// current vertex is being visited</span></span><br><span class="line">    <span class="keyword">for</span> (Integer succ: adjList.get(vertex)) &#123;  <span class="comment">// successors of current vertex</span></span><br><span class="line">        <span class="keyword">if</span> (succ != pred) &#123;  <span class="comment">// exclude current vertex's predecessor</span></span><br><span class="line">            <span class="keyword">if</span> (visited[succ] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;  <span class="comment">// back edge/loop detected!</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[succ] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasCycle(vertex, succ, visited, adjList)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[vertex] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="connectivity"><a href="#connectivity" class="headerlink" title="connectivity"></a>connectivity</h2><ul>
<li><p>static: </p>
<ul>
<li>dfs: </li>
<li><p>number of islands</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt; n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i,j,m,n,grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n, <span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,j,m,n,grid);</span><br><span class="line">            dfs(i-<span class="number">1</span>,j,m,n,grid);</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,m,n,grid);</span><br><span class="line">            dfs(i,j-<span class="number">1</span>,m,n,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bfs:<br>6.<a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="noopener">Number Of Connected Components In Undirected Graph</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static connectivity problem. use bfs or dfs solve it.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">        graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            bfs(i, graph, isVisited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(i);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">        isVisited[index] = <span class="keyword">true</span>;</span><br><span class="line">        graph.get(index).stream().filter(next -&gt; !isVisited[next]).forEach(queue::offer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>dynamic: </p>
<ul>
<li>union find</li>
<li><p><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="noopener">Number of Islands II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] positions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(m * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positions.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] position = positions[i];</span><br><span class="line">        <span class="keyword">int</span> thisPos = position[<span class="number">0</span>] * n + position[<span class="number">1</span>];</span><br><span class="line">        uf.add(thisPos);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dirs.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = position[<span class="number">0</span>] + dirs[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny = position[<span class="number">1</span>] + dirs[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextPos = nx * n + ny;</span><br><span class="line">                <span class="keyword">if</span> (uf.isLand(nextPos)) uf.union(thisPos, nextPos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        res.add(uf.count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) root[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLand</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt;=<span class="number">0</span> &amp;&amp; n &lt; root.length &amp;&amp; root[n] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        root[n] = n;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> roota = parent(a);</span><br><span class="line">        <span class="keyword">int</span> rootb = parent(b);</span><br><span class="line">        <span class="keyword">if</span> (roota != rootb) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size[roota] &lt; size[rootb]) &#123;</span><br><span class="line">                root[roota] = rootb;</span><br><span class="line">                size[rootb] += size[roota];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root[rootb] = roota;</span><br><span class="line">                size[roota] += size[rootb];</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a != root[a]) &#123;</span><br><span class="line">            root[a] = root[root[a]];</span><br><span class="line">            a = root[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/union-find/</a></p>
</li>
<li><a href="http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/</a><ul>
<li>quick find:  find(u, v): O(1), union(u, v): O(N)</li>
<li>quick union: find(u, v): O(N), union(u, v): O(1)</li>
<li>weighted quick union: find(u, v): O(logN), union(u, v): O(logN)</li>
<li>weighted with path compression: find(u, v): O(log<em>N), union(u, v): O(log</em>N)  —-<a href="https://en.wikipedia.org/wiki/Iterated_logarithm" target="_blank" rel="noopener">iterated logarithm, almost constant</a></li>
<li>implementation:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionWithPC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionWithPC</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = length;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//may not useful</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent(i) == parent(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = parent(i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = parent(j);</span><br><span class="line">        <span class="keyword">if</span> (rootI == rootJ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// make smaller root point to larger one</span></span><br><span class="line">        <span class="keyword">int</span> rootSmall = size[rootI] &lt; size[rootJ] ? rootI : rootJ;</span><br><span class="line">        <span class="keyword">int</span> rootLarge = size[rootI] &lt; size[rootJ] ? rootJ : rootI;</span><br><span class="line">        id[rootSmall] = rootLarge;</span><br><span class="line">        size[rootLarge] += size[rootSmall];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = i;</span><br><span class="line">        <span class="keyword">while</span> (root != id[root]) &#123;</span><br><span class="line">            root = id[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (root != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> old = id[i];</span><br><span class="line">            id[i] = root;</span><br><span class="line">            i = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>example:</p>
<ul>
<li><p><a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener">redundant-connection</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(edges.length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!uf.union(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = parent(k);</span><br><span class="line">        <span class="keyword">int</span> b = parent(j);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[a] &gt; size[b]) &#123; </span><br><span class="line">            root[b] = a;</span><br><span class="line">            size[a] += size[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[a] = b;</span><br><span class="line">            size[b] += size[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = a;</span><br><span class="line">        <span class="keyword">while</span>(r != root[r]) &#123;</span><br><span class="line">            r = root[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = root[a];</span><br><span class="line">            root[a] = r;</span><br><span class="line">            a = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">redundant-connection-ii</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantDirectedConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] can1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] can2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[edges[i][<span class="number">1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">                parent[edges[i][<span class="number">1</span>]] = edges[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                can2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]&#125;;</span><br><span class="line">                can1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;parent[edges[i][<span class="number">1</span>]], edges[i][<span class="number">1</span>]&#125;;</span><br><span class="line">                edges[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(edges.length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i][<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> child = edges[i][<span class="number">1</span>], father = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!uf.union(child, father)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can1[<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> can1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> can2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = parent(k);</span><br><span class="line">        <span class="keyword">int</span> b = parent(j);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[a] &gt; size[b]) &#123; </span><br><span class="line">            root[b] = a;</span><br><span class="line">            size[a] += size[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[a] = b;</span><br><span class="line">            size[b] += size[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = a;</span><br><span class="line">        <span class="keyword">while</span>(r != root[r]) &#123;</span><br><span class="line">            r = root[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = root[a];</span><br><span class="line">            root[a] = r;</span><br><span class="line">            a = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">evaluate-division</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use dfs to do it first, what's the time complexity</span></span><br><span class="line"><span class="comment">//use union find to do it second, what's the time complexity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(String[][] equations, <span class="keyword">double</span>[] values, String[][] queries) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.length];</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            uf.union(equations[i][<span class="number">0</span>], equations[i][<span class="number">1</span>], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">            res[i] = uf.calc(queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; root = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Double&gt; factor = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.containsKey(a) || !root.containsKey(b) || !findParent(a).equals(findParent(b))) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factor.get(a) / factor.get(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String a, String b, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        String ap = findParent(a);</span><br><span class="line">        String bp = findParent(b);</span><br><span class="line">        root.put(ap, bp);</span><br><span class="line">        factor.put(ap, factor.get(b) * val / factor.get(a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findParent</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.containsKey(s)) &#123;</span><br><span class="line">            root.put(s, s);</span><br><span class="line">            factor.put(s, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.get(s).equals(s)) <span class="keyword">return</span> s;</span><br><span class="line">        String lastP = root.get(s);</span><br><span class="line">        String p = findParent(lastP);</span><br><span class="line">        root.put(s, p);</span><br><span class="line">        factor.put(s, factor.get(s) * factor.get(lastP));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="shortest-path"><a href="#shortest-path" class="headerlink" title="shortest path"></a>shortest path</h2><ul>
<li><p>unweighted graph shortest path:</p>
<ul>
<li>BFS(Queue)</li>
<li><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">Shortest Distance from All Buildings</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//you want to build a house on an empty land which reaches all buildings in the shortest amount of distance. </span></span><br><span class="line"><span class="comment">//You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] offsets = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length, buildingNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    buildingNum++;</span><br><span class="line">                    update(grid, dist, reach, i, j, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span> &amp;&amp; reach[i][j] == buildingNum) &#123;</span><br><span class="line">                    min = Math.min(min, dist[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] dist, <span class="keyword">int</span>[][] reach, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(i*m + j);</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//keypoint: queue.size() will change, prefetch the size firstly!</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> curPos = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] offset: offsets) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = curPos/m + offset[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = curPos%m + offset[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (isFeasible(x, y, grid, isVisited)) &#123;</span><br><span class="line">                        dist[x][y] += steps;</span><br><span class="line">                        reach[x][y]++;</span><br><span class="line">                        isVisited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.offer(x * m + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFeasible</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] isVisited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="number">0</span> &amp;&amp; !isVisited[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>weighted graph  shortest path:</p>
<ul>
<li><p>single source: Dijkstra(not for negative): dp思想, 求一个点到其他所有点的最短路径。time complexity with PriorityQueue: O(|E| + |V|log|V|)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeWithDist</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">NodeWithDist</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    NodeWithDist(<span class="keyword">int</span> node, <span class="keyword">int</span> dist) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NodeWithDist b)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.dist &gt; b.dist) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.dist &lt; b.dist) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkatra(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.get(s).size(); ++i) &#123;</span><br><span class="line">        dist[i] =  graph.get(s).get(i) != <span class="keyword">null</span> ? graph.get(s).get(i) : Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;NodeWithDist&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != s) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> NodeWithDist(v, dist[v]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//used reached or treeSet(how to handle duplicate value) to avoid O(n) remove(obj) in PriorityQueue</span></span><br><span class="line">    <span class="comment">//laze deletion, in this way, you don't need to implement a heap with update functionality</span></span><br><span class="line">    <span class="keyword">boolean</span>[] finished = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    finished[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        Integer u = q.poll().node;</span><br><span class="line">        <span class="keyword">if</span> (!finished[u]) &#123;</span><br><span class="line">            finished[u] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer v : graph.get(u)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[u] + graph.get(u).get(v) &lt; dist[v] &amp;&amp; !finished[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + graph.get(u).get(v);</span><br><span class="line">                    q.offer(<span class="keyword">new</span> NodeWithDist(v, dist[v]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>multi source: floyd，求所有点到所有点的最短路径 O(|V|^3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//are your really understand this simple algorithm?</span></span><br><span class="line"><span class="comment">//https://www.zhihu.com/question/30955032</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floyd(<span class="keyword">int</span> graph[][], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> dist[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            dist[i][j] = graph[i][j];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="schedule-network-dependency"><a href="#schedule-network-dependency" class="headerlink" title="schedule network/dependency"></a>schedule network/dependency</h2><ul>
<li><p>topological sort: find 0 indegree node, update adjacent node’s indegree, O(V+E)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">printTologicalOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//build indegree array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer node : graph.get(i)) &#123;</span><br><span class="line">            inDegree[node]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push node with 0 indegree to queue</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete node with 0 indegree and related edge</span></span><br><span class="line">    <span class="comment">//do not need visited check for topological sort</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        Integer cur = q.poll();</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Integer node : graph.get(cur)) &#123;</span><br><span class="line">            inDegree[node]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[node] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//should check if node were all finished, if not, there must be cycle</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">course schedule</a>, </p>
</li>
<li><p><a href="https://leetcode.com/problems/alien-dictionary/" target="_blank" rel="noopener">alien dictionary</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//You receive a list of non-empty words from the dictionary, </span></span><br><span class="line"><span class="comment">//where words are sorted lexicographically by the rules of this new language. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; indegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            indegree.put(c, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = Math.min(words[i].length(), words[i + <span class="number">1</span>].length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].charAt(j) != words[i + <span class="number">1</span>].charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!graph.getOrDefault(words[i].charAt(j), <span class="keyword">new</span> HashSet&lt;&gt;()).contains(words[i + <span class="number">1</span>].charAt(j))) &#123;</span><br><span class="line">                    graph.computeIfAbsent(words[i].charAt(j), k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;()).add(words[i + <span class="number">1</span>].charAt(j));</span><br><span class="line">                    indegree.compute(words[i + <span class="number">1</span>].charAt(j), (k, v) -&gt; v + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Character&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    indegree.entrySet().stream().filter(k -&gt; k.getValue() == <span class="number">0</span>).forEach(k -&gt; q.offer(k.getKey()));</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//do not need visited check for topological sort</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = q.poll();</span><br><span class="line">        sb.append(c);</span><br><span class="line">        <span class="keyword">if</span> (graph.containsKey(c)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Character k : graph.get(c)) &#123;</span><br><span class="line">                indegree.put(k, indegree.get(k) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (indegree.get(k) == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.offer(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if nodes were not finished, must be cycle</span></span><br><span class="line">    <span class="keyword">return</span> indegree.size() != sb.length() ? <span class="string">""</span> : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/sequence-reconstruction/" target="_blank" rel="noopener">sequence-reconstruction</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check whether the original sequence org can be uniquely reconstructed from the sequences in seqs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] org, <span class="keyword">int</span>[][] seqs)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; indegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = buildGraph(org.length, seqs, indegree);</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer key : indegree.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree.get(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            q.offer(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        Integer i = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= org.length || q.size() != <span class="number">0</span> || org[index++] != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer j : graph.get(i)) &#123;</span><br><span class="line">            indegree.put(j, indegree.get(j) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (indegree.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index == org.length &amp;&amp; index == graph.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; buildGraph(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] seqs, Map&lt;Integer, Integer&gt; indegree) &#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : seqs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">            graph.putIfAbsent(arr[<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            indegree.putIfAbsent(arr[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph.containsKey(arr[i]) &amp;&amp; graph.get(arr[i]).contains(arr[i + <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                graph.putIfAbsent(arr[i + <span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                graph.computeIfAbsent(arr[i], k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;()).add(arr[i + <span class="number">1</span>]);</span><br><span class="line">                indegree.putIfAbsent(arr[i], <span class="number">0</span>);</span><br><span class="line">                indegree.put(arr[i + <span class="number">1</span>], indegree.getOrDefault(arr[i + <span class="number">1</span>], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>earliest occurence time of job</p>
</li>
<li>critical path</li>
</ul>
<h2 id="advanced-graph-algorithm"><a href="#advanced-graph-algorithm" class="headerlink" title="advanced graph algorithm"></a>advanced graph algorithm</h2><ol>
<li>spanning tree</li>
</ol>
<ul>
<li>minimum spanning tree</li>
<li>kruskal’s algorithm</li>
<li>prim’s algorithm</li>
</ul>
<ol start="2">
<li>euler cycle</li>
</ol>
<ul>
<li><p>exist condition<br>For the existence of Eulerian trails it is necessary that zero or two vertices have an odd degree; this means the Königsberg graph is not Eulerian. If there are no vertices of odd degree, all Eulerian trails are circuits. If there are exactly two vertices of odd degree, all Eulerian trails start at one of them and end at the other</p>
</li>
<li><p>hierholzer’s algorithm: iterative vs recursive, add node vs add edge</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">stack.push(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// greedily add to putative cycle, depth-first search style</span></span><br><span class="line">cycle = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = stack.pop();</span><br><span class="line">    <span class="keyword">while</span> (adj[v].hasNext()) &#123;</span><br><span class="line">        stack.push(v);</span><br><span class="line">        v = adj[v].next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add vertex with no more leaving edges to cycle</span></span><br><span class="line">    cycle.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if all edges have been used</span></span><br><span class="line"><span class="comment">// (in case there are two or more vertex-disjoint Eulerian cycles)</span></span><br><span class="line"><span class="keyword">if</span> (cycle.size() != G.E() + <span class="number">1</span>)</span><br><span class="line">    cycle = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">ReconstructItinerary</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hierholzer's algorithm to find a Eulerian path in the graph which is a valid reconstruction.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveSolution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights;</span><br><span class="line">    LinkedList&lt;String&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">        flights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String[] ticket : tickets) &#123;</span><br><span class="line">            flights.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue&lt;&gt;()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String departure)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; arrivals = flights.get(departure);</span><br><span class="line">        <span class="keyword">while</span> (arrivals != <span class="keyword">null</span> &amp;&amp; !arrivals.isEmpty()) &#123;</span><br><span class="line">            dfs(arrivals.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        path.addFirst(departure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterativeSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">            targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">        LinkedList&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (targets.containsKey(stack.peekFirst()) &amp;&amp; !targets.get(stack.peekFirst()).isEmpty())</span><br><span class="line">                stack.offerFirst(targets.get(stack.peekFirst()).poll());</span><br><span class="line">            route.addFirst(stack.removeFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*<a href="https://leetcode.com/problems/cracking-the-safe/" target="_blank" rel="noopener">cracking-the-safe</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; seen;</span><br><span class="line">StringBuilder ans;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; ++i) sb.append(<span class="string">"0"</span>);</span><br><span class="line">    String start = sb.toString();</span><br><span class="line">    dfs(start, k);</span><br><span class="line">    ans.append(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; k; ++x) &#123;</span><br><span class="line">        String nei = node + x;</span><br><span class="line">        <span class="keyword">if</span> (!seen.contains(nei)) &#123;</span><br><span class="line">            seen.add(nei);</span><br><span class="line">            dfs(nei.substring(<span class="number">1</span>), k);</span><br><span class="line">            <span class="comment">//if need record edge, record here</span></span><br><span class="line">            ans.append(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if need record nodes, record here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>naive algo<br>stupid dfs search all possible state. if not work, just go back to last work state and continue.</li>
</ul>
<ol start="3">
<li>hmilton cycle</li>
</ol>
<ul>
<li>exist condition</li>
<li>naive algorithm<br>*<a href="https://leetcode.com/problems/find-the-shortest-superstring/" target="_blank" rel="noopener">find-the-shortest-superstring</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//travel sales man problem, need to visited every node with shortest length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestSuperstring</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            graph[i][j] = calCost(A, i, j);  </span><br><span class="line">            graph[j][i] = calCost(A, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[s][i] ：表示访问了节点集合s，且最后一个节点是i的最短的路径</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n][n]; </span><br><span class="line">    <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n][n];</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE, last = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++) &#123;  <span class="comment">//枚举所有的节点集合组成状态</span></span><br><span class="line">        Arrays.fill(dp[state], Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node = <span class="number">0</span>; node &lt; n; node++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((state &amp; (<span class="number">1</span> &lt;&lt; node)) &gt; <span class="number">0</span>) &#123; <span class="comment">//判断node在不在节点集合中</span></span><br><span class="line">                <span class="keyword">int</span> leftState = state - (<span class="number">1</span> &lt;&lt; node);  <span class="comment">//剩下的节点集合</span></span><br><span class="line">                <span class="keyword">if</span> (leftState == <span class="number">0</span>) &#123;  <span class="comment">//如果只剩一个节点了，则当前长度就是node的长度</span></span><br><span class="line">                    dp[state][node] = A[node].length();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;  <span class="comment">//dp更新</span></span><br><span class="line">                        <span class="keyword">if</span> (dp[leftState][k] != Integer.MAX_VALUE &amp;&amp; </span><br><span class="line">                            dp[leftState][k] + graph[k][node] &lt; dp[state][node]) &#123;  </span><br><span class="line">                            dp[state][node] = dp[leftState][k] + graph[k][node];</span><br><span class="line">                            path[state][node] = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> &amp;&amp; dp[state][node] &lt; min) &#123;</span><br><span class="line">                min = dp[state][node];</span><br><span class="line">                last = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立路径        </span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> cur = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        stack.push(last);</span><br><span class="line">        <span class="keyword">int</span> temp = cur;</span><br><span class="line">        cur -= (<span class="number">1</span> &lt;&lt; last);</span><br><span class="line">        last = path[temp][last];</span><br><span class="line">    &#125;           </span><br><span class="line">    <span class="keyword">int</span> i = stack.pop();</span><br><span class="line">    sb.append(A[i]);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">        sb.append(A[j].substring(A[j].length() - graph[i][j]));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calCost</span><span class="params">(String[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">1</span>; pos &lt; A[i].length(); pos++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j].startsWith(A[i].substring(pos))) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[j].length() - A[i].length() + pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[j].length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*<a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/" target="_blank" rel="noopener">shortest-path-visiting-all-nodes</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return the length of the shortest path that visits every node. </span></span><br><span class="line"><span class="comment">//You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathLength</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = graph.length;</span><br><span class="line">    Queue&lt;State&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row: dist) Arrays.fill(row, N*N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; N; ++x) &#123;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> State(<span class="number">1</span>&lt;&lt;x, x));</span><br><span class="line">        dist[<span class="number">1</span> &lt;&lt; x][x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        State node = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> d = dist[node.cover][node.head];</span><br><span class="line">        <span class="keyword">if</span> (node.cover == (<span class="number">1</span>&lt;&lt;N) - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> child: graph[node.head]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cover2 = node.cover | (<span class="number">1</span> &lt;&lt; child);</span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt; dist[cover2][child]) &#123;</span><br><span class="line">                dist[cover2][child] = d + <span class="number">1</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> State(cover2, child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cover, head;</span><br><span class="line">    State(<span class="keyword">int</span> c, <span class="keyword">int</span> h) &#123;</span><br><span class="line">        cover = c;</span><br><span class="line">        head = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>maxflow</li>
</ol>
<h2 id="Question-in-leetcode"><a href="#Question-in-leetcode" class="headerlink" title="Question in leetcode"></a>Question in leetcode</h2><ul>
<li><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">Minimum Height Trees</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) solution</span></span><br><span class="line"><span class="comment">//For an undirected graph with tree characteristics, we can choose any node as the root. </span></span><br><span class="line"><span class="comment">//Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). </span></span><br><span class="line"><span class="comment">//Given such a graph, write a function to find all the MHTs and return a list of their root labels.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) adj.add(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">            adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj.get(i).size() == <span class="number">1</span>) leaves.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : leaves) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = adj.get(i).iterator().next();</span><br><span class="line">                adj.get(j).remove(i);</span><br><span class="line">                <span class="keyword">if</span> (adj.get(j).size() == <span class="number">1</span>) newLeaves.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>9.<a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">Pacific Atlantic Water Flow</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Given an m x n matrix of non-negative integers representing the height of each unit cell </span></span><br><span class="line"><span class="comment">//the "Pacific ocean" touches the left and top edges of the matrix </span></span><br><span class="line"><span class="comment">//the "Atlantic ocean" touches the right and bottom edges.</span></span><br><span class="line"><span class="comment">//Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</span></span><br><span class="line"><span class="comment">//Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</span></span><br><span class="line"><span class="comment">//bfs + two set(used to record reachable points)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    Set&lt;Integer&gt; pacificSet = getUnitSet(matrix, m, n, <span class="keyword">true</span>);</span><br><span class="line">    Set&lt;Integer&gt; atlanticSet = getUnitSet(matrix, m, n, <span class="keyword">false</span>);</span><br><span class="line">    pacificSet.retainAll(atlanticSet);</span><br><span class="line">    <span class="keyword">for</span> (Integer a : pacificSet) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a/n, a%n&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;Integer&gt; <span class="title">getUnitSet</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">boolean</span> pacific)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> row = pacific ? <span class="number">0</span> : m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> col = pacific ? <span class="number">0</span> : n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        visited.add(row * n + j);</span><br><span class="line">        queue.offer(row * n + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        visited.add(i * n + col);</span><br><span class="line">        queue.offer(i * n + col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> x = cur / n;</span><br><span class="line">        <span class="keyword">int</span> y = cur % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(matrix[x][y], matrix, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>], visited, m, n)) &#123;</span><br><span class="line">                queue.offer((x + dir[<span class="number">0</span>]) * n + y + dir[<span class="number">1</span>]);</span><br><span class="line">                visited.add((x + dir[<span class="number">0</span>]) * n + y + dir[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, Set&lt;Integer&gt; visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || visited.contains(x * n + y) || cur &gt; matrix[x][y]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>13.<a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">Word Search II</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00)</span></span><br><span class="line"><span class="comment">//dfs + trie</span></span><br><span class="line"><span class="comment">//remove visited set</span></span><br><span class="line"><span class="comment">//changed result set to list, use p.word = null after find a word</span></span><br><span class="line"><span class="comment">//remove stringBuilder, use p.word to check</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TrieNode root = buildTrie(words);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dfs (board, i, j, root, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode p, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'#'</span> || p.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    p = p.next[c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (p.word != <span class="keyword">null</span>) &#123;   <span class="comment">// found one</span></span><br><span class="line">        res.add(p.word);</span><br><span class="line">        p.word = <span class="keyword">null</span>;     <span class="comment">// de-duplicate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j ,p, res); </span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, p, res);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, p, res); </span><br><span class="line">    <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, p, res); </span><br><span class="line">    board[i][j] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : w.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.next[i] == <span class="keyword">null</span>) p.next[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p.next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p.word = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    String word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>14.<a href="https://leetcode.com/problems/word-squares/" target="_blank" rel="noopener">Word Square</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Given a set of words (without duplicates), find all word squares you can build from them.</span></span><br><span class="line"><span class="comment">//A sequence of words forms a valid word square if the kth row and column read the exact same string</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(words.length==<span class="number">0</span> || words[<span class="number">0</span>].length()==<span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> squareLen = words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1</span>;j&lt;words[<span class="number">0</span>].length();j++)</span><br><span class="line">            map.computeIfAbsent(words[i].substring(<span class="number">0</span>, j+<span class="number">1</span>), k -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(words[i]);</span><br><span class="line">    helper(ret, <span class="keyword">new</span> ArrayList&lt;String&gt;(), <span class="number">0</span>, squareLen, map);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;String&gt;&gt; ret, List&lt;String&gt; cur, <span class="keyword">int</span> matched, <span class="keyword">int</span> total, Map&lt;String, Set&lt;String&gt;&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matched == total) &#123;ret.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(cur));<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// build search string</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=matched-<span class="number">1</span>;i++) sb.append(cur.get(i).charAt(matched));</span><br><span class="line">    <span class="comment">// bachtracking</span></span><br><span class="line">    Set&lt;String&gt; cand = map.get(sb.toString());</span><br><span class="line">    <span class="keyword">if</span>(cand==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(String str:cand)&#123;</span><br><span class="line">        cur.add(str);</span><br><span class="line">        helper(ret, cur, matched+<span class="number">1</span>, total, map);</span><br><span class="line">        cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Question-in-mianjing"><a href="#Question-in-mianjing" class="headerlink" title="Question in mianjing"></a>Question in mianjing</h3><p>1.output maze solver path(iterative)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Deque&lt;Point&gt; <span class="title">solver</span><span class="params">(<span class="keyword">int</span>[][] matrix, Point start, Point end)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Point&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;Point&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    pathStack.addFirst(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!pathStack.isEmpty()) &#123;</span><br><span class="line">        Point peek = pathStack.peekFirst();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            Point next = <span class="keyword">new</span> Point(peek.x + dirs[i][<span class="number">0</span>], peek.y + dirs[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (valid(next, matrix) &amp;&amp; !visited.contains(next)) &#123;</span><br><span class="line">                pathStack.addFirst(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">                <span class="keyword">if</span> (next == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pathStack;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                pathStack.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathStack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(Point p, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x &gt;= <span class="number">0</span> &amp;&amp; p.x &lt; matrix.length &amp;&amp; p.y &gt;= <span class="number">0</span> &amp;&amp; p.y &lt; matrix[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.rolling ball maze<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.com/problems/the-maze-iii/</span></span><br><span class="line"><span class="comment">//preprocess matrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlideMaze</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录下每个点 上下左右到wall 的距离。</span></span><br><span class="line">    <span class="comment">//求最少move就bfs</span></span><br><span class="line">    <span class="comment">//求最短距离就dijk</span></span><br><span class="line">    <span class="comment">//https://googleoffer.slack.com/files/lzb700m/F1X7XDL84/p021_slidemaze.java</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * calculate the minimum moves</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, <span class="keyword">int</span> ei, <span class="keyword">int</span> ej)</span> </span>&#123;</span><br><span class="line">        Cell[][] maze = preProcess(grid);</span><br><span class="line">        Queue&lt;Cell&gt; frontier = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        frontier.offer(maze[si][sj]);</span><br><span class="line">        maze[si][sj].visited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!frontier.isEmpty()) &#123;</span><br><span class="line">            Cell cur = frontier.poll();</span><br><span class="line">            <span class="keyword">int</span>[][] dirs = &#123;&#123;-cur.bottom, <span class="number">0</span>&#125;, &#123;cur.top, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -cur.left&#125;, &#123;<span class="number">0</span>, cur.right&#125;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = cur.x + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = cur.y + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ((nx != cur.x || ny != cur.y) &amp;&amp; !maze[nx][ny].visited) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur.x == ei &amp;&amp; cur.y &gt; ej &amp;&amp; cur.y - cur.left &lt;= ej) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cur.moves + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maze[nx][ny].visited = <span class="keyword">true</span>;</span><br><span class="line">                    maze[nx][ny].moves = cur.moves + <span class="number">1</span>;</span><br><span class="line">                    frontier.offer(maze[nx][ny]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * calculate minimum distance traveled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, <span class="keyword">int</span> ei, <span class="keyword">int</span> ej)</span> </span>&#123;</span><br><span class="line">        Cell[][] maze = preProcess(grid);</span><br><span class="line">        PriorityQueue&lt;Cell&gt; frontier = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        frontier.offer(maze[si][sj]);</span><br><span class="line">        maze[si][sj].visited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!frontier.isEmpty()) &#123;</span><br><span class="line">            Cell cur = frontier.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check 4 directions</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left &gt; <span class="number">0</span> &amp;&amp; !maze[cur.x][cur.y - cur.left].visited) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.x == ei &amp;&amp; cur.y &gt; ej &amp;&amp; cur.y - cur.left &lt;= ej)</span><br><span class="line">                    <span class="keyword">return</span> cur.dist + (cur.y - ej);</span><br><span class="line">                maze[cur.x][cur.y - cur.left].visited = <span class="keyword">true</span>;</span><br><span class="line">                maze[cur.x][cur.y - cur.left].dist = cur.dist + cur.left;</span><br><span class="line">                frontier.offer(maze[cur.x][cur.y - cur.left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.right &gt; <span class="number">0</span> &amp;&amp; !maze[cur.x][cur.y + cur.right].visited) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.x == ei &amp;&amp; cur.y &lt; ej &amp;&amp; cur.y + cur.right &gt;= ej)</span><br><span class="line">                    <span class="keyword">return</span> cur.dist + (ej - cur.y);</span><br><span class="line">                maze[cur.x][cur.y + cur.right].visited = <span class="keyword">true</span>;</span><br><span class="line">                maze[cur.x][cur.y + cur.right].dist = cur.dist + cur.right;</span><br><span class="line">                frontier.offer(maze[cur.x][cur.y + cur.right]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.top &gt; <span class="number">0</span> &amp;&amp; !maze[cur.x - cur.top][cur.y].visited) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.y == ej &amp;&amp; cur.x &gt; ei &amp;&amp; cur.x - cur.top &lt;= ei)</span><br><span class="line">                    <span class="keyword">return</span> cur.dist + (cur.x - ei);</span><br><span class="line">                maze[cur.x - cur.top][cur.y].visited = <span class="keyword">true</span>;</span><br><span class="line">                maze[cur.x - cur.top][cur.y].dist = cur.dist + cur.top;</span><br><span class="line">                frontier.offer(maze[cur.x - cur.top][cur.y]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.bottom &gt; <span class="number">0</span> &amp; !maze[cur.x + cur.bottom][cur.y].visited) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.y == ej &amp;&amp; cur.x &lt; ei &amp;&amp; cur.x + cur.bottom &gt;= ei)</span><br><span class="line">                    <span class="keyword">return</span> cur.dist + (ei - cur.x);</span><br><span class="line">                maze[cur.x + cur.bottom][cur.y].visited = <span class="keyword">true</span>;</span><br><span class="line">                maze[cur.x + cur.bottom][cur.y].dist = cur.dist + cur.bottom;</span><br><span class="line">                frontier.offer(maze[cur.x + cur.bottom][cur.y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create Cell object, calculate left, right, top and bottom value for each</span></span><br><span class="line"><span class="comment">     * cell</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Cell[][] preProcess(<span class="keyword">int</span>[][] grid) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = m == <span class="number">0</span> ? <span class="number">0</span> : grid[<span class="number">0</span>].length;</span><br><span class="line">        Cell[][] maze = <span class="keyword">new</span> Cell[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maze[i][j] = <span class="keyword">new</span> Cell(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate left and right boundary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    maze[i][j].left = l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][n - j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                    maze[i][n - j - <span class="number">1</span>].right = r++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate top and bottom boundary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>, b = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    maze[i][j].top = t++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[m - i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">                    maze[m - i - <span class="number">1</span>][j].bottom = b++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maze;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cell</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> left; <span class="comment">// distance to the left border or wall</span></span><br><span class="line">        <span class="keyword">int</span> right;</span><br><span class="line">        <span class="keyword">int</span> top;</span><br><span class="line">        <span class="keyword">int</span> bottom;</span><br><span class="line">        <span class="keyword">int</span> moves; <span class="comment">// number of move to reach here from source</span></span><br><span class="line">        <span class="keyword">int</span> dist; <span class="comment">// distance (number of cells traveled) to source</span></span><br><span class="line">        <span class="keyword">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">        Cell(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = xVal;</span><br><span class="line">            <span class="keyword">this</span>.y = yVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cell(<span class="keyword">int</span> xVal, <span class="keyword">int</span> yVal, <span class="keyword">int</span> distVal) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = xVal;</span><br><span class="line">            <span class="keyword">this</span>.y = yVal;</span><br><span class="line">            <span class="keyword">this</span>.dist = distVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cell that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dist &lt; that.dist)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.dist &gt; that.dist)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.At Least K Neighbors<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给一个无向图G(V,E)还有一个正整数k,Graph表示V表示点,E表示边, 要求找到G的最大的 subset G'使得 G’中每个点至少每个点至少有 k</span></span><br><span class="line"><span class="comment"> * 个 neighbor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; maxSubGraph(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;Integer&gt; excluded = checkDegree(graph, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> vertex : excluded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.containsKey(vertex)) &#123;</span><br><span class="line">            dfsDelete(graph, vertex, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsDelete</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> vertex, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; neighbors = graph.get(vertex);</span><br><span class="line">    graph.remove(vertex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.containsKey(neighbor)) &#123;</span><br><span class="line">            Set&lt;Integer&gt; nn = graph.get(neighbor); <span class="comment">// neighbor's neighbor</span></span><br><span class="line">            nn.remove(vertex);</span><br><span class="line">            <span class="keyword">if</span> (nn.size() &lt; k)</span><br><span class="line">                dfsDelete(graph, neighbor, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">checkDegree</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> vertex : graph.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.get(vertex).size() &lt; k)</span><br><span class="line">            ans.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.break wall<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//穿墙问题 给一个m*n的board，board里面存0，1，和2，分别代表： 0 - 可申通无阻 1 - 有墙阻隔，</span></span><br><span class="line"><span class="comment">//人只能穿墙才能经过 2 - 有建筑，人无法经过.给定一个点的位置和他最多能穿的墙的数量，</span></span><br><span class="line"><span class="comment">//求到他另一个指定的点的最短路径的长度。如果路径不存在，返回-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> quota, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, <span class="keyword">int</span> ti, <span class="keyword">int</span> tj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Empty board."</span>);</span><br><span class="line">    <span class="keyword">if</span> (board[si][sj] == <span class="number">2</span> || board[ti][tj] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n][quota + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    List&lt;Cell&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    level.add(<span class="keyword">new</span> Cell(si, sj, board[si][sj]));</span><br><span class="line">    visited[si][sj][board[si][sj]] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!level.isEmpty()) &#123;</span><br><span class="line">        step++;</span><br><span class="line">        List&lt;Cell&gt; newLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Cell cell:level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d:directions) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cell.row + d[<span class="number">0</span>], j = cell.col + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (notValid(board, i, j)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = cell.wall + board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (k &gt; quota || visited[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == ti &amp;&amp; j == tj) <span class="keyword">return</span> step; <span class="comment">// reached target</span></span><br><span class="line">                visited[i][j][k] = <span class="keyword">true</span>;</span><br><span class="line">                newLevel.add(<span class="keyword">new</span> Cell(i, j, k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level = newLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">notValid</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row, col, wall;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cell</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> wall)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.col = col;</span><br><span class="line">        <span class="keyword">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.Rain and Bar<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目就是给你一个matrix，里面的数字代表bar的高度，</span></span><br><span class="line"><span class="comment">//现在说降雨量如果高于bar的高度水可以漫过去，降雨量0开始每天+1这样，</span></span><br><span class="line"><span class="comment">//问最早第几天水可以有一条路径从src漫到dst。这轮也是讨论optimization很久，</span></span><br><span class="line"><span class="comment">//最后用bfs写一个subproblem。</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/11/graph/" data-id="cjrzjgk1200084h9zswo6v0y5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/11/crack-interview/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          crack interview
        
      </div>
    </a>
  
  
    <a href="/2019/01/11/search/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Search</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/11/crack-interview/">crack interview</a>
          </li>
        
          <li>
            <a href="/2019/01/11/graph/">graph</a>
          </li>
        
          <li>
            <a href="/2019/01/11/search/">Search</a>
          </li>
        
          <li>
            <a href="/2019/01/11/dp/">dp,greedy</a>
          </li>
        
          <li>
            <a href="/2019/01/11/cpb/">Combination, Permutation, Backtracking</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>