<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>graph | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
<meta property="og:type" content="article">
<meta property="og:title" content="graph">
<meta property="og:url" content="http://yoursite.com/2019/01/11/graph/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-24T13:14:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="graph">
<meta name="twitter:description" content="summary basic knowledge representation basic traverse, found path, print path, maze cycle detection connectivity shortest path schedule networks/dependency advanced: spanning tree, euler cycle, hamlit">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-graph" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/11/graph/" class="article-date">
  <time datetime="2019-01-11T18:54:18.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      graph
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>basic knowledge</li>
<li>representation</li>
<li>basic traverse, found path, print path, maze</li>
<li>cycle detection</li>
<li>connectivity</li>
<li>shortest path</li>
<li>schedule networks/dependency</li>
<li>advanced: spanning tree, euler cycle, hamliton cycle, maxflow</li>
<li>questions</li>
</ol>
<h2 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h2><ol>
<li>connected graph</li>
<li>strongly connected</li>
<li>weekly connected</li>
<li>tree</li>
<li>spanning tree</li>
<li>min spanning tree</li>
<li>cycle</li>
<li>acyclic</li>
</ol>
<h2 id="representation"><a href="#representation" class="headerlink" title="representation"></a>representation</h2><ol>
<li>objects and pointers:</li>
<li>matrix: graph[][], graph[i][j] = 1 means i and j are connected </li>
<li>adjacent list: List&lt;List<integer>&gt; graph</integer></li>
</ol>
<h2 id="basic-traverse-found-path-print-path-maze"><a href="#basic-traverse-found-path-print-path-maze" class="headerlink" title="basic traverse, found path, print path, maze"></a>basic traverse, found path, print path, maze</h2><ol>
<li>dfs: <ul>
<li>recursion: same memory cost as iterative way, stack memory .vs. heap memory</li>
<li>iterative: stack</li>
<li>time complexity: O(V + E)</li>
<li>use case: Generate Maze, check if exist a path, print path, cycle detection</li>
</ul>
</li>
<li>bfs:<ul>
<li>recursion: no</li>
<li>iterative: Queue or rolling array</li>
<li>time complexity: O(V + E)</li>
<li>use case: Min distance(only deal with weight = 1), </li>
<li><strong>multi-end bfs</strong> to solve <a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">Walls and Gates</a></li>
</ul>
</li>
</ol>
<h2 id="cycle-detection"><a href="#cycle-detection" class="headerlink" title="cycle detection"></a>cycle detection</h2><ul>
<li><p>undirected graph:<br>  dfs with <strong>visited[] and parent</strong> check, <a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">LC261:Graph Valid Tree</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleDetectionInUndirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(i, visit, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">boolean</span>[] visit, List&lt;List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        visit[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node : graph.get(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[node]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(node, visit, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>directed graph:<br>  cycle-detection: <a href="http://www.geeksforgeeks.org/detect-cycle-in-a-graph/" target="_blank" rel="noopener">DFS, white, grey, black</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleDetectionInDirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//o represent white, 1 represent grey, 2 represent black</span></span><br><span class="line">        <span class="keyword">int</span>[] nodeColors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeColors[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(i, nodeColors, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsCycle</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] nodeColors, List&lt;List&lt;Integer&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        nodeColors[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> node : graph.get(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeColors[node] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeColors[node] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (containsCycle(node, nodeColors, graph)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeColors[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="connectivity"><a href="#connectivity" class="headerlink" title="connectivity"></a>connectivity</h2><ul>
<li><p>example:</p>
<ul>
<li><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">evaluate-division</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use dfs to do it first, what's the time complexity</span></span><br><span class="line"><span class="comment">//use union find to do it second, what's the time complexity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(String[][] equations, <span class="keyword">double</span>[] values, String[][] queries) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.length];</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            uf.union(equations[i][<span class="number">0</span>], equations[i][<span class="number">1</span>], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">            res[i] = uf.calc(queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; root = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Double&gt; factor = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.containsKey(a) || !root.containsKey(b) || !findParent(a).equals(findParent(b))) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factor.get(a) / factor.get(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String a, String b, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        String ap = findParent(a);</span><br><span class="line">        String bp = findParent(b);</span><br><span class="line">        root.put(ap, bp);</span><br><span class="line">        factor.put(ap, factor.get(b) * val / factor.get(a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findParent</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.containsKey(s)) &#123;</span><br><span class="line">            root.put(s, s);</span><br><span class="line">            factor.put(s, <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.get(s).equals(s)) <span class="keyword">return</span> s;</span><br><span class="line">        String lastP = root.get(s);</span><br><span class="line">        String p = findParent(lastP);</span><br><span class="line">        root.put(s, p);</span><br><span class="line">        factor.put(s, factor.get(s) * factor.get(lastP));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>static: </p>
<ul>
<li>dfs: <a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">LC261:Graph Valid Tree</a></li>
<li>bfs: <a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="noopener">LC323:Number of Connected Components in an Undirected Graph</a></li>
</ul>
</li>
<li>dynamic: <ul>
<li>union find</li>
</ul>
</li>
<li><a href="http://www.cs.princeton.edu/courses/archive/spring07/cos226/lectures/01union-find.pdf" target="_blank" rel="noopener">union find/2D</a>(for connectivity): <ul>
<li><a href="https://leetcode.com/problems/number-of-islands-ii/" target="_blank" rel="noopener">Number of Islands II</a></li>
<li><a href="http://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/union-find/</a></li>
<li><a href="http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/</a><ul>
<li>quick find:  find(u, v): O(1), union(u, v): O(N)</li>
<li>quick union: find(u, v): O(N), union(u, v): O(1)</li>
<li>weighted quick union: find(u, v): O(logN), union(u, v): O(logN)</li>
<li>weighted with path compression: find(u, v): O(log<em>N), union(u, v): O(log</em>N)  —-<a href="https://en.wikipedia.org/wiki/Iterated_logarithm" target="_blank" rel="noopener">iterated logarithm, almost constant</a></li>
<li>implementation:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionWithPC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionWithPC</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = length;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//may not useful</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent(i) == parent(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = parent(i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = parent(j);</span><br><span class="line">        <span class="keyword">if</span> (rootI == rootJ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// make smaller root point to larger one</span></span><br><span class="line">        <span class="keyword">int</span> rootSmall = size[rootI] &lt; size[rootJ] ? rootI : rootJ;</span><br><span class="line">        <span class="keyword">int</span> rootLarge = size[rootI] &lt; size[rootJ] ? rootJ : rootI;</span><br><span class="line">        id[rootSmall] = rootLarge;</span><br><span class="line">        size[rootLarge] += size[rootSmall];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = i;</span><br><span class="line">        <span class="keyword">while</span> (root != id[root]) &#123;</span><br><span class="line">            root = id[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (root != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> old = id[i];</span><br><span class="line">            id[i] = root;</span><br><span class="line">            i = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="shortest-path"><a href="#shortest-path" class="headerlink" title="shortest path"></a>shortest path</h2><ul>
<li>unweighted graph shortest path:<ul>
<li>BFS(Queue)</li>
</ul>
</li>
<li><p>weighted graph  shortest path:</p>
<ul>
<li><p>single source: Dijkstra(not for negative): dp思想, 求一个点到其他所有点的最短路径。time complexity with PriorityQueue: O(|E| + |V|log|V|)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeWithDist</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">NodeWithDist</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    NodeWithDist(<span class="keyword">int</span> node, <span class="keyword">int</span> dist) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NodeWithDist b)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.dist &gt; b.dist) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.dist &lt; b.dist) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkatra(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.get(s).size(); ++i) &#123;</span><br><span class="line">        dist[i] =  graph.get(s).get(i) != <span class="keyword">null</span> ? graph.get(s).get(i) : Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;NodeWithDist&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != s) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> NodeWithDist(v, dist[v]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//used reached or treeSet(how to handle duplicate value) to avoid O(n) remove(obj) in PriorityQueue</span></span><br><span class="line">    <span class="comment">//laze deletion, in this way, you don't need to implement a heap with update functionality</span></span><br><span class="line">    <span class="keyword">boolean</span>[] finished = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    finished[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        Integer u = q.poll().node;</span><br><span class="line">        <span class="keyword">if</span> (!finished[u]) &#123;</span><br><span class="line">            finished[u] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer v : graph.get(u)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[u] + graph.get(u).get(v) &lt; dist[v] &amp;&amp; !finished[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + graph.get(u).get(v);</span><br><span class="line">                    q.offer(<span class="keyword">new</span> NodeWithDist(v, dist[v]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>multi source: floyd，求所有点到所有点的最短路径 O(|V|^3)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from geeksforgeeks</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floyd(<span class="keyword">int</span> graph[][], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> dist[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="comment">/* Initialize the solution matrix same as input graph matrix.</span></span><br><span class="line"><span class="comment">       Or we can say the initial values of shortest distances</span></span><br><span class="line"><span class="comment">       are based on shortest paths considering no intermediate</span></span><br><span class="line"><span class="comment">       vertex. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dist[i][j] = graph[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add all vertices one by one to the set of intermediate</span></span><br><span class="line"><span class="comment">       vertices.</span></span><br><span class="line"><span class="comment">      ---&gt; Before start of a iteration, we have shortest</span></span><br><span class="line"><span class="comment">           distances between all pairs of vertices such that</span></span><br><span class="line"><span class="comment">           the shortest distances consider only the vertices in</span></span><br><span class="line"><span class="comment">           set &#123;0, 1, 2, .. k-1&#125; as intermediate vertices.</span></span><br><span class="line"><span class="comment">      ----&gt; After the end of a iteration, vertex no. k is added</span></span><br><span class="line"><span class="comment">            to the set of intermediate vertices and the set</span></span><br><span class="line"><span class="comment">            becomes &#123;0, 1, 2, .. k&#125; */</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="comment">// Pick all vertices as source one by one</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// Pick all vertices as destination for the</span></span><br><span class="line">            <span class="comment">// above picked source</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// If vertex k is on the shortest path from</span></span><br><span class="line">                <span class="comment">// i to j, then update the value of dist[i][j]</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="schedule-network-dependency"><a href="#schedule-network-dependency" class="headerlink" title="schedule network/dependency"></a>schedule network/dependency</h2><ul>
<li><p>topological sort: find 0 indegree node, update adjacent node’s indegree, O(V+E)</p>
<ul>
<li>e.g: <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">course schedule</a>, <a href="https://leetcode.com/problems/alien-dictionary/" target="_blank" rel="noopener">alien dictionary</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">printTologicalOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//build indegree array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer node : graph.get(i)) &#123;</span><br><span class="line">            inDegree[node]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push node with 0 indegree to queue</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete node with 0 indegree and related edge</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        Integer cur = q.poll();</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Integer node : graph.get(cur)) &#123;</span><br><span class="line">            inDegree[node]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[node] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>earliest occurence time of job</p>
</li>
<li>critical path</li>
</ul>
<h2 id="advanced-graph-algorithm"><a href="#advanced-graph-algorithm" class="headerlink" title="advanced graph algorithm"></a>advanced graph algorithm</h2><ol>
<li>spanning tree</li>
</ol>
<ul>
<li>minimum spanning tree</li>
<li>kruskal’s algorithm</li>
<li>prim’s algorithm</li>
</ul>
<ol start="2">
<li>euler cycle</li>
</ol>
<ul>
<li><p>exist condition<br>For the existence of Eulerian trails it is necessary that zero or two vertices have an odd degree; this means the Königsberg graph is not Eulerian. If there are no vertices of odd degree, all Eulerian trails are circuits. If there are exactly two vertices of odd degree, all Eulerian trails start at one of them and end at the other</p>
</li>
<li><p>fleury’s algorithm</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less efficient than hierholzer</span><br></pre></td></tr></table></figure>
</li>
<li><p>hierholzer’s algorithm</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">stack.push(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// greedily add to putative cycle, depth-first search style</span></span><br><span class="line">cycle = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = stack.pop();</span><br><span class="line">    <span class="keyword">while</span> (adj[v].hasNext()) &#123;</span><br><span class="line">        stack.push(v);</span><br><span class="line">        v = adj[v].next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add vertex with no more leaving edges to cycle</span></span><br><span class="line">    cycle.push(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if all edges have been used</span></span><br><span class="line"><span class="comment">// (in case there are two or more vertex-disjoint Eulerian cycles)</span></span><br><span class="line"><span class="keyword">if</span> (cycle.size() != G.E() + <span class="number">1</span>)</span><br><span class="line">    cycle = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>naive algo<br>stupid dfs search all possible state. if not work, just go back to last work state and continue.</p>
</li>
</ul>
<ol start="3">
<li>hmilton cycle</li>
</ol>
<ul>
<li>exist condition</li>
<li>naive algorithm</li>
</ul>
<ol start="4">
<li>maxflow</li>
</ol>
<h2 id="Question-in-leetcode"><a href="#Question-in-leetcode" class="headerlink" title="Question in leetcode"></a>Question in leetcode</h2><p>1.<a href="https://leetcode.com/problems/alien-dictionary/" target="_blank" rel="noopener">alien dictionary</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependency problem: topological sort</span><br></pre></td></tr></table></figure></p>
<p>2.<a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bfs + hashMap, remember check if the node was visited.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UndirectedGraphNode root = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; nodesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nodesMap.put(node, root);</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode curNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode neighbor : curNode.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodesMap.containsKey(neighbor)) &#123;</span><br><span class="line">                    nodesMap.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                nodesMap.get(curNode).neighbors.add(nodesMap.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<a href="https://leetcode.com/problems/graph-valid-tree/" target="_blank" rel="noopener">Graph Valid Tree</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check cycle in undirected graph</span></span><br><span class="line"><span class="comment">//check if connected</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">            graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle(-<span class="number">1</span>, <span class="number">0</span>, visited, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  <span class="comment">// has cycle</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: visited) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// not 1 single connected component</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">int</span> pred, <span class="keyword">int</span> vertex, <span class="keyword">int</span>[] visited, List&lt;List&lt;Integer&gt;&gt; adjList)</span> </span>&#123;</span><br><span class="line">        visited[vertex] = <span class="number">1</span>;  <span class="comment">// current vertex is being visited</span></span><br><span class="line">        <span class="keyword">for</span> (Integer succ: adjList.get(vertex)) &#123;  <span class="comment">// successors of current vertex</span></span><br><span class="line">            <span class="keyword">if</span> (succ != pred) &#123;  <span class="comment">// exclude current vertex's predecessor</span></span><br><span class="line">                <span class="keyword">if</span> (visited[succ] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;  <span class="comment">// back edge/loop detected!</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (visited[succ] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hasCycle(vertex, succ, visited, adjList)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[vertex] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">Longest Increasing Path In Matrix</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs + memorization, time complexity: O(n*m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> [][] offsets = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, findMaxLen(matrix, <span class="number">1</span>, i, j, cache));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxLen</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> tempLen, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] cache)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] offset : offsets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isInMatrix(matrix, i + offset[<span class="number">0</span>], j + offset[<span class="number">1</span>]) &amp;&amp; matrix[i + offset[<span class="number">0</span>]][j + offset[<span class="number">1</span>]] &gt; matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">1</span> + findMaxLen(matrix, tempLen + <span class="number">1</span>, i + offset[<span class="number">0</span>], j + offset[<span class="number">1</span>], cache);</span><br><span class="line">                curLen = Math.max(curLen, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[i][j] = curLen;</span><br><span class="line">        <span class="keyword">return</span> curLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; matrix.length &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length &amp;&amp; j &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.<a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">Minimum Height Trees</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n) solution</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> Collections.singletonList(<span class="number">0</span>);</span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) adj.add(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            adj.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">            adj.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj.get(i).size() == <span class="number">1</span>) leaves.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            n -= leaves.size();</span><br><span class="line">            List&lt;Integer&gt; newLeaves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : leaves) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = adj.get(i).iterator().next();</span><br><span class="line">                adj.get(j).remove(i);</span><br><span class="line">                <span class="keyword">if</span> (adj.get(j).size() == <span class="number">1</span>) newLeaves.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            leaves = newLeaves;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leaves;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.<a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="noopener">Number Of Connected Components In Undirected Graph</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static connectivity problem. use bfs or dfs solve it.</span></span><br></pre></td></tr></table></figure></p>
<p>7.number of islands<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt; n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i,j,m,n,grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n, <span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,j,m,n,grid);</span><br><span class="line">            dfs(i-<span class="number">1</span>,j,m,n,grid);</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,m,n,grid);</span><br><span class="line">            dfs(i,j-<span class="number">1</span>,m,n,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8.number of islands 2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynamic connectivity problem: union-find</span></span><br></pre></td></tr></table></figure></p>
<p>9.<a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">Pacific Atlantic Water Flow</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bfs + two set(used to record reachable points)</span></span><br></pre></td></tr></table></figure></p>
<p>10.<a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">ReconstructItinerary</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//see related problem, 最短破解4位密码锁序列长度问题</span></span><br><span class="line"><span class="comment">//Hierholzer's algorithm to find a Eulerian path in the graph which is a valid reconstruction.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights;</span><br><span class="line">    LinkedList&lt;String&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">        flights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String[] ticket : tickets) &#123;</span><br><span class="line">            flights.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue&lt;&gt;()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String departure)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; arrivals = flights.get(departure);</span><br><span class="line">        <span class="keyword">while</span> (arrivals != <span class="keyword">null</span> &amp;&amp; !arrivals.isEmpty()) &#123;</span><br><span class="line">            dfs(arrivals.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        path.addFirst(departure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets)</span><br><span class="line">        targets.computeIfAbsent(ticket[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> PriorityQueue()).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    List&lt;String&gt; route = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (targets.containsKey(stack.peek()) &amp;&amp; !targets.get(stack.peek()).isEmpty())</span><br><span class="line">            stack.push(targets.get(stack.peek()).poll());</span><br><span class="line">        route.add(<span class="number">0</span>, stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>11.<a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/" target="_blank" rel="noopener">Shortest Distance from All Buildings</a></p>
<p>12.<a href="https://leetcode.com/problems/walls-and-gates/" target="_blank" rel="noopener">Walls and Gates</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//multi-end bfs</span></span><br></pre></td></tr></table></figure></p>
<p>13.<a href="">Word Search II</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs + trie</span></span><br><span class="line"><span class="comment">//remove visited set</span></span><br><span class="line"><span class="comment">//changed result set to list, use p.word = null after find a word</span></span><br><span class="line"><span class="comment">//remove stringBuilder, use p.word to check</span></span><br></pre></td></tr></table></figure></p>
<p>14.<a href="">Word Square</a></p>
<h3 id="Question-in-mianjing"><a href="#Question-in-mianjing" class="headerlink" title="Question in mianjing"></a>Question in mianjing</h3><p>1.output maze solver path(iterative)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Deque&lt;Point&gt; <span class="title">solver</span><span class="params">(<span class="keyword">int</span>[][] matrix, Point start, Point end)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Point&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;Point&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    pathStack.addFirst(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!pathStack.isEmpty()) &#123;</span><br><span class="line">        Point peek = pathStack.peekFirst();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            Point next = <span class="keyword">new</span> Point(peek.x + dirs[i][<span class="number">0</span>], peek.y + dirs[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (valid(next, matrix) &amp;&amp; !visited.contains(next)) &#123;</span><br><span class="line">                pathStack.addFirst(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">                <span class="keyword">if</span> (next == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pathStack;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                pathStack.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathStack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(Point p, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x &gt;= <span class="number">0</span> &amp;&amp; p.x &lt; matrix.length &amp;&amp; p.y &gt;= <span class="number">0</span> &amp;&amp; p.y &lt; matrix[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.output maze solver path(recursion)</p>
<p>3.generate maze</p>
<p>4.rolling ball maze<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//preprocess matrix</span></span><br></pre></td></tr></table></figure></p>
<p>5.At Least K Neighbors<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给一个无向图G(V,E)还有一个正整数k,Graph表示V表示点,E表示边, 要求找到G的最大的 subset G'使得 G’中每个点至少每个点至少有 k</span></span><br><span class="line"><span class="comment"> * 个 neighbor.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>6.break wall<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//穿墙问题 给一个m*n的board，board里面存0，1，和2，分别代表： 0 - 可申通无阻 1 - 有墙阻隔，</span></span><br><span class="line"><span class="comment">//人只能穿墙才能经过 2 - 有建筑，人无法经过.给定一个点的位置和他最多能穿的墙的数量，</span></span><br><span class="line"><span class="comment">//求到他另一个指定的点的最短路径的长度。如果路径不存在，返回-1</span></span><br></pre></td></tr></table></figure></p>
<p>7.Rain and Bar<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目就是给你一个matrix，里面的数字代表bar的高度，</span></span><br><span class="line"><span class="comment">//现在说降雨量如果高于bar的高度水可以漫过去，降雨量0开始每天+1这样，</span></span><br><span class="line"><span class="comment">//问最早第几天水可以有一条路径从src漫到dst。这轮也是讨论optimization很久，</span></span><br><span class="line"><span class="comment">//最后用bfs写一个subproblem。</span></span><br></pre></td></tr></table></figure></p>
<p>8.Remove BackEdges</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/11/graph/" data-id="cjran2ob800054q9z6w3adc6y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/11/crack-interview/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          crack interview
        
      </div>
    </a>
  
  
    <a href="/2019/01/11/search/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Search</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/11/crack-interview/">crack interview</a>
          </li>
        
          <li>
            <a href="/2019/01/11/graph/">graph</a>
          </li>
        
          <li>
            <a href="/2019/01/11/search/">Search</a>
          </li>
        
          <li>
            <a href="/2019/01/11/dp/">dp</a>
          </li>
        
          <li>
            <a href="/2019/01/11/cpb/">Combination, Permutation, Backtracking</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>